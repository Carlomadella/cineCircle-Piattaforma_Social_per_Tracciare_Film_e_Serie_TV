# Introduzione al Progetto

Ti propongo di creare **CineCircle**, una piattaforma dove le persone appassionate di cinema e serie televisive possono tenere traccia di tutto quello che hanno visto, scrivere le loro opinioni personali, creare liste di contenuti che vogliono guardare in futuro, e seguire altri utenti per scoprire nuovi titoli interessanti attraverso i loro gusti. Pensa a questa piattaforma come a un diario digitale cinematografico dove ogni utente può costruire la propria storia con film e serie TV.

La bellezza di questo progetto è che non dovrai gestire pagamenti, carrelli della spesa o transazioni complesse. Ti concentrerai invece sulla creazione di un'esperienza sociale e interattiva dove gli utenti possono esprimere le loro passioni cinematografiche, scoprire nuovi contenuti e connettersi con persone che hanno gusti simili.

## Milestone Obbligatorie

Queste sono le funzionalità che devi assolutamente implementare. Rappresentano il cuore della tua applicazione e permettono agli utenti di fare tutte le operazioni fondamentali.

### 1. Homepage

La tua homepage sarà la prima cosa che gli utenti vedono quando arrivano sulla piattaforma. Nella parte alta della pagina creerai uno spazio hero, che è un'area grande e visivamente d'impatto con un'immagine di sfondo cinematografica e magari un titolo che spiega cos'è CineCircle. Sotto questo spazio hero, dovrai mostrare almeno due sezioni di contenuti. La prima sezione potrebbe essere "I più popolari questa settimana", dove mostri i film e le serie TV che sono stati aggiunti alle collezioni più volte negli ultimi giorni. La seconda sezione potrebbe essere "Meglio recensiti dalla community", dove mostri i contenuti che hanno ricevuto le valutazioni più alte dagli utenti. Ogni contenuto verrà mostrato con la sua locandina, il titolo e magari il rating medio. Quando un utente clicca su una di queste locandine, verrà portato alla pagina di dettaglio di quel film o serie.

### 2. Pagina di Ricerca

Questa è la pagina dove gli utenti possono esplorare tutto il catalogo di film e serie TV disponibili. In alto avrai una barra di ricerca dove l'utente può digitare il titolo di un film che sta cercando. Mentre digita, la pagina mostrerà i risultati che corrispondono a quello che ha scritto. Accanto alla barra di ricerca, dovrai mettere delle opzioni per ordinare i risultati. L'utente potrà scegliere se ordinare per nome del film in ordine alfabetico, per anno di uscita dal più recente al più vecchio, oppure per rating medio dalla valutazione più alta alla più bassa. I risultati della ricerca verranno mostrati sotto forma di card, ognuna con la locandina del film, il titolo, l'anno di uscita e il rating medio. Quando l'utente clicca su una card, viene portato alla pagina di dettaglio di quel contenuto.

### 3. Pagina di Dettaglio Contenuto

Quando un utente clicca su un film o una serie TV, arriva a questa pagina dove può vedere tutte le informazioni dettagliate. Sulla sinistra mostrerai la locandina del film in dimensioni grandi. Sulla destra metterai tutte le informazioni importanti come il titolo completo, l'anno di uscita, la durata del film o il numero di stagioni se è una serie, il genere cinematografico come azione o commedia, il nome del regista e degli attori principali. Sotto queste informazioni ci sarà la trama completa del film. In una sezione ben visibile mostrerai il rating medio che questo contenuto ha ricevuto dalla community, calcolato dalla media di tutte le recensioni degli utenti. Se l'utente è registrato e ha fatto login, vedrà dei pulsanti per interagire con il contenuto. Il pulsante più importante è quello per aggiungere il film alla propria collezione personale. Quando clicca questo pulsante, si apre un menu dove può scegliere lo stato, cioè se ha già visto questo film, se lo sta guardando in questo momento, o se vuole vederlo in futuro.

### 4. Collezione Personale

Ogni utente registrato ha una collezione personale dove vengono salvati tutti i film e le serie TV che ha aggiunto. Questa collezione è divisa in diverse categorie basate sullo stato che l'utente ha scelto. Avrai una sezione per i contenuti che l'utente ha già visto completamente, una sezione per quelli che sta guardando in questo momento, e una sezione per quelli che vuole vedere in futuro. In ogni sezione, i contenuti vengono mostrati con le loro locandine disposte in una griglia. L'utente può modificare lo stato di un contenuto in qualsiasi momento. Per esempio, se ha aggiunto un film nella lista "Voglio vedere" e poi lo guarda, può spostarlo nella lista "Visto". Può anche rimuovere completamente un contenuto dalla sua collezione se cambia idea.

### 5. Profilo Utente e Recensioni

Ogni utente ha un profilo personale dove può gestire le sue informazioni e vedere tutte le sue attività sulla piattaforma. Nel profilo ci sono diverse sezioni. La prima mostra le informazioni base come username, immagine profilo e una biografia breve che l'utente può scrivere su se stesso. Poi c'è una sezione che mostra statistiche interessanti come quanti film ha visto in totale, quali sono i suoi generi preferiti calcolati automaticamente dai film nella sua collezione, e quante recensioni ha scritto. La parte più importante del profilo è la sezione delle recensioni. Qui l'utente può vedere tutte le recensioni che ha scritto nel tempo. Ogni recensione mostra il film a cui si riferisce, il voto che l'utente ha dato da una a cinque stelle, il testo dove spiega la sua opinione, e quando l'ha scritta. L'utente può modificare o cancellare le sue recensioni in qualsiasi momento. Quando scrivi una recensione per un film, devi inserire un voto numerico e un testo dove esprimi la tua opinione. La recensione viene poi salvata nel database e mostrata nella pagina di dettaglio di quel film, così anche altri utenti possono leggerla.

### 6. Invio Email

Quando un utente si registra sulla piattaforma, il sistema deve inviargli automaticamente una email di benvenuto. Questa email conferma che la registrazione è andata a buon fine e dà il benvenuto all'utente nella community di CineCircle. L'email conterrà il nome utente che ha scelto e magari qualche suggerimento su come iniziare a usare la piattaforma. Per implementare questa funzionalità userai una libreria chiamata Nodemailer nel tuo backend Node.js con Express. Nodemailer ti permette di configurare un servizio email e inviare messaggi in modo semplice. Durante lo sviluppo puoi usare un servizio gratuito come Gmail configurando un'app password specifica per la tua applicazione, oppure usare servizi di testing come Mailtrap che ti permettono di vedere le email inviate senza che vengano davvero spedite a indirizzi reali.

## Milestone Extra - Scegli Almeno 10 Punti

Oltre alle funzionalità obbligatorie, devi scegliere e implementare alcune funzionalità extra dalla lista qui sotto. Ogni funzionalità ha un coefficiente di difficoltà. Devi scegliere un insieme di funzionalità la cui somma dei coefficienti raggiunga almeno dieci punti. Puoi sceglierne anche di più se vuoi, ma ricorda che tutto quello che scegli dovrai poi implementarlo completamente.

### 1. Doppia Visualizzazione dei Risultati (Coefficiente: 1)

Nella pagina di ricerca, darai all'utente la possibilità di scegliere come visualizzare i risultati. Ci saranno due modalità di visualizzazione. La prima è la visualizzazione a griglia, dove ogni film viene mostrato come una card con la locandina grande e poche informazioni sotto come titolo e anno. Le card sono disposte una accanto all'altra in una griglia responsiva. La seconda modalità è la visualizzazione a lista, dove ogni risultato è una riga che occupa tutta la larghezza della pagina. In questa modalità la locandina è più piccola e posizionata sulla sinistra, mentre sulla destra ci sono molte più informazioni visibili come il titolo, l'anno, il regista, i generi e una parte della trama. L'utente può cambiare modalità cliccando su un'icona in alto nella pagina, magari un'icona con delle grigliette per la vista griglia e un'icona con delle linee per la vista lista. Quando cambia modalità, i risultati si riorganizzano immediatamente senza ricaricare la pagina.

### 2. Filtri Avanzati (Coefficiente: 2)

Oltre alla barra di ricerca base, aggiungerai dei filtri che permettono all'utente di restringere i risultati in modo più preciso. Questi filtri saranno posizionati sulla sinistra della pagina di ricerca, o in un menu che si apre su mobile. Il primo filtro sarà per i generi cinematografici. L'utente potrà selezionare uno o più generi come azione, commedia, horror, fantascienza e così via. Quando seleziona un genere, la pagina mostrerà solo i film che appartengono a quel genere. Il secondo filtro sarà per l'anno di uscita. L'utente potrà impostare un anno minimo e un anno massimo, per esempio per vedere solo film usciti tra il duemila e il duemiladieci. Un terzo filtro utile potrebbe essere per il rating minimo, così l'utente può vedere solo film che hanno una valutazione media sopra un certo valore, per esempio solo film con almeno quattro stelle. Quando l'utente applica o modifica i filtri, la lista dei risultati si aggiorna automaticamente mostrando solo i contenuti che corrispondono a tutti i filtri attivi.

### 3. Contenuti in Evidenza (Coefficiente: 2)

Alcuni film o serie TV saranno marcati come "in evidenza" nel database. Questi contenuti in evidenza verranno mostrati in modo speciale nella homepage. Avrai una sezione dedicata, magari con uno slider o un carosello che mostra questi contenuti uno alla volta con transizioni animate. Ogni contenuto in evidenza avrà un'immagine più grande e accattivante, magari uno screenshot dal film invece della semplice locandina. Ci sarà anche la possibilità di filtrare per contenuti in evidenza nella pagina di ricerca, così gli utenti possono vedere rapidamente i titoli che la piattaforma sta promuovendo in quel momento. Nel database aggiungerai un campo booleano nella tabella dei contenuti che indica se quel contenuto è in evidenza oppure no.

### 4. Liste Personalizzate (Coefficiente: 2)

Gli utenti potranno creare liste personalizzate di film e serie TV. Una lista è una raccolta tematica che l'utente crea per organizzare i contenuti come preferisce. Per esempio, potrebbe creare una lista chiamata "I miei film horror preferiti" e aggiungere tutti gli horror che gli piacciono. Oppure "Film da vedere ad Halloween" per pianificare una maratona. Ogni utente può creare quante liste vuole. Quando crea una lista, deve darle un nome e può aggiungere una descrizione opzionale che spiega il tema della lista. Ogni lista può essere marcata come pubblica o privata. Le liste pubbliche sono visibili a tutti gli altri utenti che visitano il profilo, mentre quelle private sono visibili solo al proprietario. All'interno di una lista, l'utente può aggiungere qualsiasi film o serie TV dalla piattaforma. Può anche riordinare i contenuti nella lista trascinandoli in posizioni diverse se vuole creare una classifica personale. Le liste verranno mostrate nel profilo utente con delle card che mostrano il nome della lista e le locandine dei primi film che contiene.

### 5. Paginazione dei Risultati (Coefficiente: 2)

Quando ci sono molti risultati nella pagina di ricerca, invece di mostrarli tutti insieme, li dividerai in pagine. Per esempio, mostrerai venti risultati per pagina. In fondo alla lista dei risultati ci saranno dei controlli di navigazione. L'utente vedrà su quale pagina si trova attualmente, per esempio "Pagina due di dieci". Ci saranno pulsanti per andare alla pagina precedente e alla pagina successiva. Potresti anche mostrare i numeri delle pagine cliccabili, magari mostrando la pagina corrente e alcune pagine intorno ad essa. Quando l'utente cambia pagina, la pagina web caricherà i nuovi risultati dal server e mostrerà la seconda serie di venti film. Un dettaglio importante è che quando l'utente cambia pagina, tutti i filtri che aveva applicato devono rimanere attivi. Se aveva filtrato per genere horror e va alla pagina due, deve continuare a vedere solo horror. Inoltre, lo stato della ricerca e della paginazione deve essere salvato nell'URL, quindi se l'utente copia il link della pagina e lo condivide con un amico, l'amico vedrà gli stessi risultati sulla stessa pagina. Potresti anche aggiungere un menu a tendina che permette all'utente di scegliere quanti risultati vedere per pagina, con opzioni come dieci, venti o cinquanta risultati.

### 6. Contenuti Correlati (Coefficiente: 2)

Nella pagina di dettaglio di un film, aggiungerai una sezione in fondo che mostra altri film simili o correlati. Questi contenuti correlati vengono calcolati in base a caratteristiche comuni. Il modo più semplice per trovare contenuti correlati è cercare film che hanno lo stesso genere. Per esempio, se l'utente sta guardando un film d'azione, mostri altri film d'azione. Un altro criterio potrebbe essere lo stesso regista, così se all'utente piace un film di un certo regista, può scoprire facilmente altri lavori dello stesso autore. Oppure potresti mostrare film con attori in comune. La sezione dei contenuti correlati mostrerà quattro o cinque film in una riga orizzontale con le loro locandine. Ogni locandina sarà cliccabile e porterà alla pagina di dettaglio di quel film. Questa funzionalità è molto utile perché incoraggia l'utente a continuare l'esplorazione e scoprire nuovi contenuti che probabilmente gli piaceranno.

### 7. Sistema di Follow (Coefficiente: 3)

Aggiungerai una componente sociale alla piattaforma permettendo agli utenti di seguirsi a vicenda. Quando visiti il profilo di un altro utente, vedrai un pulsante "Segui" se non lo stai già seguendo, oppure "Smetti di seguire" se lo stai già seguendo. Quando segui qualcuno, le sue attività appariranno nel tuo feed personale. Il feed è una pagina dedicata dove vedi cosa stanno facendo le persone che segui, per esempio quando aggiungono un nuovo film alla loro collezione o quando scrivono una nuova recensione. Ogni utente avrà nel suo profilo due numeri visibili che mostrano quante persone sta seguendo e quante persone lo seguono. Questi numeri saranno cliccabili e mostreranno la lista completa. Questa funzionalità richiede di creare una nuova tabella nel database per memorizzare le relazioni di follow tra utenti, e di implementare una pagina feed che mostra le attività recenti in ordine cronologico.

### 8. Statistiche Dettagliate (Coefficiente: 3)

Nel profilo utente aggiungerai una sezione dedicata alle statistiche personali che va oltre i semplici numeri. Creerai visualizzazioni grafiche interattive che mostrano dati interessanti sull'attività dell'utente. Il primo grafico potrebbe essere un diagramma a torta che mostra la distribuzione dei generi guardati. Se un utente ha visto trenta film di cui quindici sono azione, dieci sono commedia e cinque sono horror, il grafico mostrerà queste proporzioni con colori diversi. Un secondo grafico potrebbe essere un grafico a linee che mostra quanti film l'utente ha visto nel tempo, magari raggruppati per mese. Questo permette di vedere i periodi in cui è stato più attivo. Potresti anche mostrare quale regista ha visto di più, quale anno ha prodotto i suoi film preferiti, e qual è la sua durata media preferita dei film. Per creare questi grafici userai una libreria JavaScript chiamata Chart.js che è disponibile tramite CDN e ti permette di creare grafici belli e interattivi senza dover scrivere tutto il codice da zero.

### 9. Gestione Avanzata Collezione (Coefficiente: 3)

Oltre agli stati base della collezione, aggiungerai funzionalità più avanzate per organizzare i contenuti. L'utente potrà aggiungere una data di quando ha visto un film, così può tenere traccia cronologica delle sue visioni. Potrà anche aggiungere note personali a ogni contenuto nella sua collezione, per esempio per ricordarsi dove lo ha visto o con chi. Nella pagina della collezione, aggiungerai filtri e ordinamenti avanzati. L'utente potrà ordinare i film per data di aggiunta alla collezione, per rating che ha dato, o per anno di uscita del film. Potrà anche cercare all'interno della sua collezione digitando un titolo. Implementerai anche una funzionalità di esportazione dove l'utente può scaricare la sua collezione come file di testo o CSV, utile se vuole fare un backup o condividerla in altri modi.

### 10. Commenti alle Recensioni (Coefficiente: 3)

Gli utenti potranno commentare le recensioni scritte da altri utenti. Sotto ogni recensione ci sarà una sezione commenti dove le persone possono lasciare la loro opinione sulla recensione o iniziare una discussione sul film. Ogni commento mostrerà il nome dell'utente che lo ha scritto, il testo del commento e quando è stato pubblicato. L'autore di una recensione riceverà una notifica quando qualcuno commenta la sua recensione. Gli utenti potranno anche modificare o cancellare i propri commenti. Questa funzionalità aggiunge un livello di interazione sociale importante perché trasforma le recensioni da monologhi a conversazioni. Dovrai creare una nuova tabella nel database per i commenti e implementare nuovi endpoint nella tua API per crearli, leggerli, modificarli e cancellarli.

### 11. Confronta Contenuti (Coefficiente: 4)

Gli utenti potranno selezionare fino a tre film o serie TV e confrontarli in una tabella comparativa. Mentre navigano la piattaforma, vedranno un pulsante "Aggiungi al confronto" su ogni contenuto. Quando cliccano questo pulsante, il contenuto viene aggiunto a una lista di confronto temporanea. In qualsiasi momento l'utente può aprire il pannello di confronto che mostra tutti i contenuti selezionati. Quando ha scelto almeno due contenuti, può cliccare "Confronta" e verrà portato a una pagina dedicata dove i contenuti sono mostrati in colonne affiancate. Ogni riga della tabella rappresenta una caratteristica come anno di uscita, genere, regista, durata, rating medio e numero di recensioni. Questo permette all'utente di vedere a colpo d'occhio le differenze e le similitudini tra i contenuti. È particolarmente utile quando sta cercando di decidere quale film guardare tra diverse opzioni. La lista di confronto sarà salvata nel local storage del browser così persiste anche se l'utente chiude e riapre la pagina.

### 12. Integrazione API Esterna Film (Coefficiente: 5)

Invece di inserire manualmente tutti i dati dei film nel database, integrerai un'API esterna che fornisce informazioni sui film. L'API più famosa e completa è The Movie Database, conosciuta come TMDB. Questa API gratuita ti permette di cercare film, ottenere dettagli completi con locandine, trame, cast, registi e molto altro. Quando un amministratore vuole aggiungere un nuovo film alla piattaforma, invece di inserire tutti i dati manualmente, può semplicemente cercare il film tramite l'API TMDB. L'API restituisce tutte le informazioni che poi salvi nel tuo database. Puoi anche usare l'API per tenere aggiornate le informazioni, per esempio per aggiungere automaticamente i nuovi film che escono al cinema. Per implementare questa funzionalità dovrai registrarti sul sito di TMDB per ottenere una chiave API gratuita, poi nel tuo backend farai chiamate a questa API per ottenere i dati. Dovrai creare degli endpoint nella tua API che fungono da ponte tra il tuo frontend e l'API esterna, gestendo le chiamate e formattando i dati nel modo che ti serve.

## Requisiti Tecnici Fondamentali

Questi sono requisiti che devi rispettare obbligatoriamente per il tuo progetto. Sono le linee guida tecniche che garantiscono che la tua applicazione sia di qualità professionale.

Il sito deve essere completamente responsive, il che significa che deve funzionare bene e avere un aspetto gradevole su tutti i dispositivi. Che l'utente lo apra su un computer desktop con uno schermo grande, su un tablet, o su uno smartphone, l'interfaccia deve adattarsi in modo fluido mostrando i contenuti in modo appropriato per quella dimensione di schermo. Userai Bootstrap come framework CSS che ti aiuta moltissimo in questo perché fornisce una griglia responsiva e componenti già pronti che si adattano automaticamente.

Devi utilizzare le tecnologie che hai studiato, quindi HTML per la struttura, CSS e Bootstrap per lo stile, JavaScript per l'interattività, React per costruire l'interfaccia utente come componenti riutilizzabili, Node.js con Express per il backend, e MySQL per il database. Questa combinazione di tecnologie è perfetta per un progetto di questa dimensione e complessità.

Tutti i dati che gli utenti inseriscono devono essere validati sia nel frontend che nel backend. Nel frontend, quando un utente compila un form come la registrazione o la scrittura di una recensione, devi controllare che i dati siano nel formato corretto prima ancora di inviarli al server. Per esempio, se chiedi un'email, devi verificare che quello che l'utente ha scritto sia effettivamente nel formato di un'email con la chiocciola e un dominio. Se la password deve avere almeno otto caratteri, devi controllarlo e mostrare un messaggio di errore se non è abbastanza lunga. Poi, quando i dati arrivano al backend, devi fare di nuovo tutti questi controlli perché un utente malintenzionato potrebbe cercare di bypassare i controlli del frontend. La validazione doppia garantisce che solo dati corretti e sicuri vengano salvati nel database.

La pagina non deve mai eseguire un refresh completo. Questo significa che quando l'utente naviga da una pagina all'altra, per esempio dalla homepage alla pagina di ricerca, il browser non deve ricaricare tutto da zero con la classica schermata bianca lampeggiante. Invece, React cambierà solo le parti della pagina che sono diverse, mantenendo la barra di navigazione e gli altri elementi comuni. Questo crea un'esperienza molto più fluida e veloce, simile a quella di un'app mobile. Per ottenere questo risultato userai React Router che gestisce la navigazione lato client.

Devi gestire il caso della pagina che non esiste, la classica pagina quattrocentoquattro. Quando un utente digita un URL che non corrisponde a nessuna pagina della tua applicazione, per esempio se scrive slash film slash novantanove ma non esiste un film con quell'ID, invece di mostrare un errore brutto del browser, mostrerai una pagina quattrocentoquattro personalizzata. Questa pagina avrà un design coerente con il resto del sito, un messaggio chiaro che spiega che quella pagina non esiste, e magari dei link per tornare alla homepage o alla ricerca. Questo migliora tantissimo l'esperienza utente perché anche quando qualcosa va storto, l'utente non si sente perso.

I risultati di ricerca devono essere condivisibili tramite URL. Quando un utente fa una ricerca con dei filtri specifici, per esempio cerca film di genere horror usciti dopo il duemila e li ordina per rating, l'URL della pagina deve riflettere questi parametri. Potrebbe essere qualcosa come slash search question mark genre equal horror and year equal duemila and sort equal rating. Se l'utente copia questo URL e lo manda a un amico, l'amico aprendo il link vedrà esattamente gli stessi risultati di ricerca con gli stessi filtri applicati. Questo si implementa usando i query parameters nell'URL che React Router ti permette di leggere e modificare.

L'ID dei contenuti non deve mai essere esposto direttamente agli utenti. Gli ID nel database sono numeri progressivi come uno, due, tre, e se un utente li vede nell'URL potrebbe essere tentato di cambiarli manualmente per vedere contenuti che magari non dovrebbe vedere, o potrebbe capire quanti contenuti totali ci sono nel database. Invece di usare l'ID numerico nell'URL, userai uno slug, che è una versione del titolo del film formattata per essere usata negli URL. Per esempio, se il film si chiama "Il Padrino", lo slug potrebbe essere "il-padrino". L'URL sarà slash film slash il-padrino invece di slash film slash uno. Nel database avrai sia l'ID numerico che usi internamente, sia lo slug che usi negli URL pubblici.

## Struttura del Database MySQL

Ora parliamo in dettaglio di come organizzerai i tuoi dati nel database MySQL. Un database ben progettato è la base di qualsiasi applicazione web di successo, e ti semplificherà enormemente il lavoro quando dovrai scrivere il codice per recuperare e salvare i dati.

### Tabella Users

Questa tabella contiene tutte le informazioni sugli utenti registrati alla piattaforma. Ogni utente sarà una riga in questa tabella e avrà questi campi. Il campo id è un numero intero che si incrementa automaticamente e identifica in modo univoco ogni utente. È la chiave primaria della tabella. Il campo username è una stringa che contiene il nome utente scelto durante la registrazione, deve essere unico perché non possono esistere due utenti con lo stesso username. Il campo email è anch'esso una stringa unica che contiene l'indirizzo email dell'utente. Il campo password conterrà la password dell'utente ma non in chiaro, bensì hashata usando una libreria chiamata bcrypt che trasforma la password in una stringa incomprensibile che può essere verificata ma non decifrata. Il campo bio è una stringa opzionale dove l'utente può scrivere una breve descrizione di se stesso, può essere lasciata vuota. Il campo profile_image è una stringa che contiene l'URL di un'immagine profilo, anche questa opzionale. I campi created_at e updated_at sono timestamp che registrano quando l'utente si è registrato e quando ha modificato il suo profilo l'ultima volta.

### Tabella Contents

Questa è una delle tabelle più importanti perché contiene tutti i film e le serie TV disponibili sulla piattaforma. Ogni riga rappresenta un contenuto diverso. Il campo id è la chiave primaria auto-incrementale. Il campo title contiene il titolo completo del film o della serie. Il campo slug contiene la versione del titolo formattata per l'URL, tutto minuscolo e con i trattini al posto degli spazi, per esempio "il-signore-degli-anelli". Il campo description contiene la trama o sinossi completa del contenuto. Il campo poster_url è una stringa con l'URL dell'immagine della locandina. Il campo type è un enum che può avere solo due valori possibili, "movie" per i film o "tv_series" per le serie televisive. Il campo year è un numero intero che indica l'anno di uscita. Il campo duration è un numero intero che indica la durata in minuti per i film, o il numero di stagioni per le serie TV. Il campo director è una stringa con il nome del regista o dei creatori. Il campo cast può essere una stringa che contiene i nomi degli attori principali separati da virgole. Il campo average_rating è un numero decimale che viene calcolato dalla media di tutte le recensioni e si aggiorna ogni volta che qualcuno scrive una nuova recensione. Il campo popularity_count è un numero intero che conta quante volte questo contenuto è stato aggiunto alle collezioni degli utenti, utile per calcolare i contenuti più popolari. Il campo is_featured è un booleano che indica se questo contenuto deve essere mostrato nella sezione in evidenza della homepage.

### Tabella Genres

Questa tabella contiene tutti i generi cinematografici disponibili. È una tabella semplice con solo due campi. Il campo id è la chiave primaria, e il campo name contiene il nome del genere come "Action", "Comedy", "Drama", "Horror", "Science Fiction" e così via.

### Tabella Content_Genres

Questa è una tabella di relazione molti a molti tra Contents e Genres. Un film può appartenere a più generi contemporaneamente, e ogni genere contiene molti film. Questa tabella ha tre campi. Il campo id è la chiave primaria. Il campo content_id è una foreign key che punta alla tabella Contents e indica di quale film stiamo parlando. Il campo genre_id è una foreign key che punta alla tabella Genres e indica quale genere stiamo associando a quel film. Ogni riga di questa tabella rappresenta quindi l'associazione tra un film specifico e un genere specifico.

### Tabella User_Contents

Questa tabella rappresenta la collezione personale di ogni utente. Ogni riga collega un utente a un contenuto e memorizza lo stato di quella relazione. Il campo id è la chiave primaria. Il campo user_id è una foreign key che punta all'utente proprietario di questa entry. Il campo content_id è una foreign key che punta al contenuto nella sua collezione. Il campo status è un enum che può essere "watched" se l'utente ha già visto questo contenuto, "watching" se lo sta guardando in questo momento, "want_to_watch" se vuole vederlo in futuro, o "dropped" se ha iniziato a guardarlo ma lo ha abbandonato. Il campo added_at è un timestamp che registra quando l'utente ha aggiunto questo contenuto alla sua collezione. Il campo watched_at è un timestamp opzionale che registra quando l'utente ha completato la visione, viene compilato quando lo stato diventa "watched".

### Tabella Reviews

Questa tabella contiene tutte le recensioni scritte dagli utenti. Ogni recensione è collegata a un utente che l'ha scritta e a un contenuto a cui si riferisce. Il campo id è la chiave primaria. Il campo user_id è una foreign key che indica chi ha scritto questa recensione. Il campo content_id è una foreign key che indica a quale film o serie si riferisce. Il campo rating è un numero intero da uno a cinque che rappresenta il voto che l'utente ha dato. Il campo text è un testo lungo che contiene l'opinione dell'utente sul contenuto. Il campo created_at registra quando la recensione è stata pubblicata. Il campo updated_at registra quando è stata modificata l'ultima volta. È importante aggiungere un vincolo unique sulla coppia user_id e content_id perché ogni utente può scrivere una sola recensione per ogni contenuto.

### Tabella Lists

Questa tabella contiene le liste personalizzate create dagli utenti. Il campo id è la chiave primaria. Il campo user_id è una foreign key che indica chi ha creato questa lista. Il campo name è una stringa con il nome della lista scelto dall'utente. Il campo description è un testo opzionale dove l'utente può descrivere il tema della lista. Il campo is_public è un booleano che indica se la lista è visibile a tutti o solo al proprietario. Il campo created_at registra quando la lista è stata creata.

### Tabella List_Items

Questa è una tabella di relazione molti a molti tra Lists e Contents. Una lista contiene molti contenuti, e un contenuto può essere in molte liste diverse. Il campo id è la chiave primaria. Il campo list_id è una foreign key che punta alla lista. Il campo content_id è una foreign key che punta al contenuto. Il campo position è un numero intero che indica la posizione di questo contenuto all'interno della lista, così l'utente può ordinare i contenuti come preferisce. Il campo added_at registra quando questo contenuto è stato aggiunto alla lista.

### Tabella Follows

Questa tabella gestisce le relazioni sociali tra utenti. È molto semplice con tre campi. Il campo id è la chiave primaria. Il campo follower_id è una foreign key che punta all'utente che sta seguendo qualcun altro. Il campo following_id è una foreign key che punta all'utente che viene seguito. Il campo created_at registra quando il follow è iniziato. Ogni riga rappresenta quindi una relazione di follow tra due utenti.

### Tabella Activity_Feed

Questa tabella opzionale memorizza le attività degli utenti per costruire facilmente il feed sociale. Il campo id è la chiave primaria. Il campo user_id è una foreign key che indica chi ha compiuto l'attività. Il campo activity_type è una stringa che descrive il tipo di attività, per esempio "new_review", "added_to_collection", "created_list". Il campo content_id è una foreign key opzionale che punta al contenuto coinvolto nell'attività se rilevante. Il campo created_at registra quando l'attività è avvenuta.

Tutte queste tabelle useranno il motore di storage InnoDB di MySQL che supporta le foreign key e le transazioni. Le foreign key avranno constraint appropriati, la maggior parte userà ON DELETE CASCADE che significa che se cancelli un utente, tutte le sue recensioni, liste e relazioni di follow vengono cancellate automaticamente.

## Architettura dell'API Backend

Il tuo backend sarà costruito con Node.js usando il framework Express. L'API seguirà i principi REST, quindi ogni risorsa avrà URL chiari e userà i metodi HTTP in modo semantico. Organizzerai il codice in modo modulare per mantenere tutto ordinato e facile da modificare.

### Struttura delle Cartelle

Creerai diverse cartelle nel tuo progetto backend. La cartella routes conterrà tutti i file che definiscono gli endpoint dell'API, organizzati per risorsa. Avrai file come authRoutes.js per autenticazione, contentsRoutes.js per i contenuti, reviewsRoutes.js per le recensioni e così via. La cartella controllers conterrà la logica di business, quindi le funzioni che vengono eseguite quando un endpoint viene chiamato. La cartella models definirà come interagire con il database, probabilmente userai un query builder o scriverai le query SQL direttamente. La cartella middleware conterrà funzioni riutilizzabili come quella per verificare l'autenticazione o per validare i dati in ingresso. La cartella utils conterrà funzioni di utilità come quella per hashare le password o generare token.

### Autenticazione con JWT

Per gestire l'autenticazione userai JSON Web Tokens. Quando un utente fa login inviando email e password, il server controlla che le credenziali siano corrette. Per farlo, cerca l'utente nel database usando l'email. Se trova l'utente, usa la libreria bcrypt per confrontare la password inserita con l'hash salvato nel database. Se corrispondono, significa che la password è corretta. A questo punto il server genera un JWT usando la libreria jsonwebtoken. Il token contiene nel suo payload l'ID dell'utente e il suo username. Il token viene firmato con una chiave segreta che solo il server conosce, così nessuno può creare token falsi. Poi il token viene mandato al client che lo salverà e lo includerà in tutte le richieste successive.

Nel frontend, quando ricevi il token dopo il login, lo salvi nel local storage del browser usando localStorage.setItem. Poi, ogni volta che fai una richiesta a un endpoint protetto, recuperi il token con localStorage.getItem e lo metti nell'header della richiesta. Nel backend creerai un middleware di autenticazione che viene eseguito prima di certi endpoint. Questo middleware legge il token dall'header della richiesta, lo verifica usando la chiave segreta, e se è valido estrae l'ID dell'utente e lo aggiunge all'oggetto request. Così nei controller successivi puoi usare request.user.id per sapere chi sta facendo la richiesta.

### Endpoint Principali

Ora vediamo quali endpoint creerai nella tua API e cosa faranno. Ti darò una panoramica generale, poi quando implementerai potrai approfondire i dettagli.

Per l'autenticazione avrai POST slash auth slash register dove l'utente invia username, email e password nel body della richiesta. Il server controlla che l'email non esista già, hasha la password, crea un nuovo record nella tabella users e invia l'email di benvenuto. Poi c'è POST slash auth slash login dove l'utente invia email e password, il server verifica le credenziali e restituisce il JWT. C'è anche POST slash auth slash logout che nel caso dei JWT serve principalmente a far sì che il client elimini il token, ma potresti implementare una blacklist se vuoi invalidare token dal lato server.

Per i contenuti, l'endpoint principale è GET slash contents che restituisce una lista di film e serie TV. Questo endpoint accetta vari query parameters nell'URL. Il parametro search contiene la keyword da cercare nei titoli e nelle descrizioni. Il parametro genre contiene l'ID del genere per filtrare solo contenuti di quel genere. Il parametro year contiene l'anno o un range di anni. Il parametro sort indica come ordinare i risultati, può essere "title" per ordine alfabetico, "year" per anno di uscita, "rating" per valutazione media. I parametri page e limit gestiscono la paginazione, per esempio page uguale due e limit uguale venti significa che vuoi la seconda pagina di risultati con venti contenuti per pagina. Il server costruisce una query SQL che include tutti questi filtri e ordinamenti, la esegue sul database, e restituisce un oggetto JSON con i risultati e informazioni sulla paginazione.

Poi c'è GET slash contents slash slug dove slug è lo slug del contenuto che vuoi vedere. Questo endpoint restituisce tutti i dettagli di quel singolo contenuto. Il server fa una query che oltre a prendere i dati base del contenuto, fa un join con la tabella dei generi per includere tutti i generi associati, calcola la media delle recensioni, e magari include anche alcuni contenuti simili. Se l'utente è autenticato, il server controlla anche se quel contenuto è già nella sua collezione e in che stato.

Per la collezione personale, tutti gli endpoint richiedono autenticazione. GET slash my-collection restituisce tutti i contenuti nella collezione dell'utente loggato. Può accettare un parametro status per filtrare solo i contenuti in un certo stato. POST slash my-collection richiede un body con content_id e status, e aggiunge quel contenuto alla collezione dell'utente con lo stato specificato. PUT slash my-collection slash content-id permette di cambiare lo stato di un contenuto già nella collezione. DELETE slash my-collection slash content-id rimuove un contenuto dalla collezione.

Per le recensioni, GET slash reviews slash content-slug restituisce tutte le recensioni per quel contenuto, ordinate dalla più recente. POST slash reviews crea una nuova recensione dove il body contiene content_id, rating e text. Il server verifica che l'utente non abbia già recensito quel contenuto, salva la recensione nel database, e aggiorna il campo average_rating del contenuto ricalcolando la media. PUT slash reviews slash id modifica una recensione esistente, ma prima controlla che l'utente che fa la richiesta sia il proprietario di quella recensione. DELETE slash reviews slash id elimina una recensione con lo stesso controllo di proprietà.

Per le liste personalizzate, GET slash lists restituisce tutte le liste pubbliche o le liste dell'utente loggato se autenticato. GET slash lists slash id restituisce i dettagli di una lista specifica con tutti i contenuti che contiene. POST slash lists crea una nuova lista dove il body contiene name, description e is_public. PUT slash lists slash id modifica una lista esistente. DELETE slash lists slash id elimina una lista. POST slash lists slash id slash items aggiunge un contenuto a una lista, il body contiene content_id. DELETE slash lists slash id slash items slash content-id rimuove un contenuto da una lista.

Per il sistema di follow, POST slash follow slash user-id crea una relazione di follow tra l'utente loggato e l'utente specificato. DELETE slash follow slash user-id rimuove la relazione di follow. GET slash following restituisce tutti gli utenti che stai seguendo. GET slash followers restituisce tutti gli utenti che ti seguono. GET slash feed restituisce le attività recenti degli utenti che segui, interrogando la tabella activity_feed.

Per le statistiche, GET slash stats slash user-id restituisce statistiche personali dell'utente come numero totale di contenuti visti, distribuzione per generi, e altre informazioni calcolate dai suoi dati. GET slash stats slash global restituisce statistiche della piattaforma come i contenuti più popolari e i generi più seguiti.

### Validazione dei Dati

Ogni endpoint che riceve dati dall'utente deve validarli prima di usarli. Puoi creare funzioni di validazione personalizzate o usare una libreria. Per esempio, quando un utente si registra, devi controllare che lo username sia lungo almeno tre caratteri e non contenga caratteri speciali strani, che l'email sia in formato valido con la chiocciola e un dominio, e che la password sia lunga almeno otto caratteri. Se qualcosa non va, restituisci subito un errore quattrocento con un messaggio chiaro che spiega il problema, per esempio "La password deve essere lunga almeno otto caratteri".

### Gestione degli Errori

Creerai un sistema centralizzato per gestire gli errori. Alla fine della catena di middleware di Express, metterai un error handler che cattura tutti gli errori che non sono stati gestiti prima. Questo middleware riceve l'errore, determina che tipo di errore è, e restituisce una risposta JSON appropriata. Per esempio, se è un errore di validazione restituisce quattrocento con il messaggio di validazione. Se è un errore di autenticazione restituisce quattrocentouno. Se è una risorsa non trovata restituisce quattrocentoquattro. Per errori inaspettati che non hai previsto, restituisce cinquecento con un messaggio generico senza esporre dettagli interni che potrebbero essere informazioni sensibili.

## Frontend con React

Il frontend sarà costruito interamente con React, che ti permette di creare interfacce utente modulari e riutilizzabili organizzate in componenti. React rende molto più facile gestire lo stato dell'applicazione e aggiornare l'interfaccia quando i dati cambiano.

### Struttura dei Componenti

Organizzerai la tua applicazione in componenti che rappresentano pezzi dell'interfaccia. Avrai componenti grandi che rappresentano pagine intere come HomePage, SearchPage, ContentDetailPage, ProfilePage. E avrai componenti più piccoli e riutilizzabili come ContentCard che mostra un film in una card, ReviewCard che mostra una recensione, Header per la barra di navigazione in alto, Footer per il piè di pagina. Ogni componente sarà in un file separato, così il codice rimane ordinato.

Un componente React è una funzione che restituisce del codice simile a HTML ma che si chiama JSX. All'interno del componente puoi usare JavaScript per gestire logica e dati. Per esempio, un componente ContentCard potrebbe ricevere come prop le informazioni di un film e mostrarle in una bella card con l'immagine della locandina, il titolo e il rating.

### Gestione dello Stato

React ti permette di creare stato all'interno dei componenti usando l'hook useState. Lo stato è una variabile che quando cambia fa sì che React riaggiorni automaticamente l'interfaccia. Per esempio, in una pagina di ricerca potresti avere uno stato per la keyword di ricerca, uno stato per i filtri applicati, uno stato per i risultati ottenuti dal server, e uno stato per indicare se i dati stanno caricando.

Per lo stato che deve essere accessibile da molti componenti diversi, come le informazioni dell'utente loggato, userai Context API di React. Creerai un AuthContext che mantiene lo stato dell'utente e del token JWT, e fornisce funzioni per fare login e logout. Qualsiasi componente nell'applicazione può accedere a questo contesto per sapere se c'è un utente loggato e chi è.

### Navigazione con React Router

Userai React Router per gestire la navigazione tra le diverse pagine senza ricaricare il browser. Definirai tutte le route della tua applicazione in un posto centrale. Ogni route associa un path URL a un componente da mostrare. Per esempio, la route slash mostra HomePage, la route slash search mostra SearchPage, la route slash content slash due punti slug mostra ContentDetailPage. Il due punti slug è un parametro dinamico, quindi ogni film avrà un URL diverso come slash content slash il-padrino.

Per navigare tra le pagine, invece di usare normali tag a href che ricaricherebbero la pagina, userai il componente Link di React Router. Quando l'utente clicca un Link, React Router cambia solo la parte dell'interfaccia che è diversa senza ricaricare nulla, creando un'esperienza molto fluida.

Alcune route richiederanno che l'utente sia autenticato. Per proteggerle creerai un componente PrivateRoute che controlla se c'è un utente loggato, e se non c'è redirige automaticamente alla pagina di login.

### Chiamare l'API

Per comunicare con il tuo backend, farai richieste HTTP dalla tua applicazione React. Il modo più semplice per farlo è con la funzione fetch che è nativa in JavaScript. Quando vuoi ottenere dati dal server, chiamerai fetch passandogli l'URL dell'endpoint. Per esempio, per ottenere la lista di contenuti faresti fetch verso http due punti slash slash localhost due punti tremila slash contents. Fetch restituisce una Promise, quindi dovrai gestirla.

Ecco un esempio semplificato senza usare async e await. Diciamo che hai un componente che deve caricare la lista di contenuti quando viene montato. Nel tuo componente userai l'hook useEffect che ti permette di eseguire codice quando il componente appare sulla pagina. All'interno di useEffect chiamerai fetch. Quando fetch finisce di recuperare i dati, chiamerai il metodo .then sulla Promise per ottenere la risposta. Poi chiamerai response.json per estrarre i dati JSON dalla risposta, e questo restituisce un'altra Promise. Chiamerai .then di nuovo per ottenere i dati effettivi, e a quel punto li salverai nello stato del componente con setState. Se qualcosa va storto, gestirai l'errore con .catch.

Se devi inviare dati al server, per esempio per creare una recensione, userai fetch con il metodo POST. Passerai un oggetto di configurazione come secondo parametro a fetch, specificando il method come POST, gli headers per dire che stai inviando JSON, e il body con i dati convertiti in stringa JSON usando JSON.stringify.

Se l'endpoint richiede autenticazione, dovrai includere il token JWT nell'header della richiesta. Prima recupererai il token dal local storage, poi lo aggiungerai agli headers della richiesta come Authorization due punti Bearer spazio il token.

### Le Pagine Principali

Vediamo in dettaglio cosa conterranno le pagine più importanti della tua applicazione.

La Homepage sarà la prima impressione che gli utenti hanno della tua piattaforma. In alto ci sarà una hero section con un'immagine di sfondo a tema cinematografico, magari una foto di una sala cinematografica o un montaggio di locandine famose. Sopra l'immagine ci sarà il logo di CineCircle e un titolo accattivante che spiega cos'è la piattaforma, tipo "Il tuo diario cinematografico digitale". Sotto la hero section avrai diverse sezioni. La prima mostrerà i contenuti più popolari della settimana, quindi i film e le serie che sono stati aggiunti più volte alle collezioni negli ultimi giorni. Userai un componente griglia con le card dei contenuti. La seconda sezione mostrerà i contenuti meglio recensiti, quindi quelli con il rating medio più alto. Una terza sezione potrebbe mostrare gli ultimi arrivi, cioè i contenuti più recentemente aggiunti alla piattaforma. Se hai implementato i contenuti in evidenza come milestone extra, ci sarà anche una sezione dedicata con uno slider o carosello. Per caricare tutti questi dati farai diverse chiamate API quando il componente HomePage viene montato.

La pagina di ricerca è il cuore dell'esplorazione. In alto avrai una barra di ricerca grande e ben visibile. Mentre l'utente digita, lo stato della keyword si aggiorna. Quando l'utente finisce di digitare o preme invio, farai una chiamata all'API con la keyword per ottenere i risultati. Accanto alla barra di ricerca ci saranno dei controlli per ordinare i risultati. Potresti usare un menu a tendina o dei pulsanti che permettono di scegliere tra ordinamento per nome, anno o rating. Quando l'utente cambia l'ordinamento, aggiornerai lo stato e farai una nuova chiamata API con il parametro sort appropriato. Se hai implementato i filtri avanzati, ci sarà una sezione laterale o un pannello espandibile con tutti i filtri disponibili. Ogni volta che l'utente modifica un filtro, aggiornerai lo stato e farai una nuova ricerca. I risultati verranno mostrati in una griglia di ContentCard. Se hai implementato la doppia visualizzazione, ci sarà un toggle in alto che permette di passare dalla vista griglia alla vista lista. Quando l'utente clicca questo toggle, cambierai uno stato che indica la modalità di visualizzazione corrente, e i componenti si riorganizzeranno di conseguenza. Se hai implementato la paginazione, in fondo alla pagina ci saranno i controlli per cambiare pagina. Quando l'utente clicca su una pagina diversa, aggiornerai lo stato della pagina corrente e farai una nuova chiamata API con il parametro page giusto. Molto importante, ogni volta che cambi ricerca, filtri, ordinamento o pagina, devi anche aggiornare l'URL usando i query parameters. React Router ti permette di farlo facilmente, e questo garantisce che l'URL sia sempre condivisibile e che se l'utente fa refresh rimane sulla stessa ricerca.

La pagina di dettaglio di un contenuto mostra tutte le informazioni su un film o serie TV specifica. Il componente leggerà lo slug dall'URL usando i parametri di React Router. Quando il componente viene montato, farà una chiamata API a GET slash contents slash slug per ottenere tutti i dati. Mentre i dati caricano, mostrerai un loading indicator tipo uno spinner o skeleton screen. Quando i dati arrivano, li salverai nello stato e li mostrerai. Il layout della pagina avrà la locandina grande sulla sinistra, e sulla destra tutte le informazioni testuali organizzate in sezioni chiare. Il titolo sarà grande e prominente, sotto ci sarà l'anno, la durata e i generi mostrati come piccoli badge colorati. Più sotto il regista e il cast, e poi la trama completa. In una posizione ben visibile mostrerai il rating medio con delle stelle o un numero grande, insieme al numero totale di recensioni ricevute. Se l'utente è loggato, vedrai dei pulsanti per interagire. Un pulsante per aggiungere il contenuto alla collezione che quando cliccato apre un piccolo menu dropdown dove l'utente può scegliere lo stato. Quando sceglie uno stato, farai una chiamata POST all'API per salvare questa informazione. Un altro pulsante permetterà di scrivere o modificare la recensione, aprendo un modal o portando a una sezione della pagina dove c'è un form. Sotto le informazioni principali ci sarà la sezione delle recensioni esistenti. Ogni recensione sarà mostrata in una ReviewCard con il nome dell'utente che l'ha scritta, il suo rating con le stelle, il testo della recensione e quando è stata pubblicata. Se è la recensione dell'utente loggato, mostrerà anche pulsanti per modificarla o eliminarla. Se hai implementato i contenuti correlati, in fondo alla pagina ci sarà una sezione che mostra altri film simili, caricati sempre dall'API, in una riga orizzontale scrollabile.

Il profilo utente avrà diverse sezioni accessibili tramite tab o navigazione interna. La prima sezione mostra una panoramica con l'immagine profilo, lo username, la bio se presente, e alcune statistiche chiave come numero di contenuti visti e recensioni scritte. La sezione collezione mostrerà tutti i contenuti che l'utente ha aggiunto organizzati per stato. Potresti avere dei tab per passare tra "Visti", "Voglio vedere" e "Sto guardando". Ogni stato mostrerà una griglia di ContentCard. La sezione liste mostrerà tutte le liste create dall'utente, ognuna come una card con il nome della lista e le prime locandine dei contenuti che contiene. La sezione recensioni mostrerà tutte le ReviewCard delle recensioni scritte dall'utente in ordine cronologico. Se hai implementato le statistiche dettagliate, ci sarà una sezione dedicata con grafici interattivi. Se stai visitando il profilo di un altro utente e hai implementato il sistema di follow, vedrai un pulsante in alto per seguirlo o smettere di seguirlo, che farà chiamate POST o DELETE all'API appropriata.

### Form e Validazione

I form come registrazione, login e scrittura recensioni saranno componenti React controllati. Questo significa che ogni input del form avrà il suo valore collegato allo stato del componente. Quando l'utente digita, un handler onChange aggiornerà lo stato. Quando l'utente sottomette il form, un handler onSubmit verrà chiamato. In questo handler farai la validazione dei dati. Controllerai che tutti i campi obbligatori siano compilati, che le email siano nel formato giusto, che le password rispettino i requisiti. Se c'è un errore, aggiornerai uno stato che contiene i messaggi di errore e li mostrerai sotto i campi appropriati con testo rosso. Se tutto è valido, farai la chiamata API per inviare i dati al server. Se il server risponde con successo, mostrerai un messaggio positivo o naviderai a un'altra pagina. Se il server risponde con un errore, mostrerai il messaggio di errore ricevuto.

### Stile e Responsività

Userai Bootstrap come framework CSS base. Includerai Bootstrap nel tuo progetto tramite CDN mettendo il link nel file HTML principale. Bootstrap ti fornisce una griglia responsive basata su dodici colonne e molti componenti pre-stilizzati come bottoni, card, navbar e form. Quando crei un layout, userai le classi di Bootstrap come container, row e col per strutturare la pagina. Le classi col hanno modificatori per diverse dimensioni di schermo come col-md-sei che significa che su schermi medi quella colonna occupa sei delle dodici colonne disponibili.

Oltre a Bootstrap, scriverai CSS custom per personalizzare l'aspetto e dare alla tua app un'identità unica. Creerai un file style.css dove definirai il tuo color scheme, la tipografia personalizzata da Google Fonts, e gli stili per i tuoi componenti specifici. Userai transizioni CSS per rendere le interazioni fluide, per esempio quando l'utente passa il mouse su una card potresti farla sollevare leggermente con un'ombra più pronunciata usando transition su transform e box-shadow.

Per le icone userai Font Awesome che è una libreria di icone vettoriali. La includerai via CDN e poi potrai usare le icone mettendo tag i con le classi appropriate, per esempio i class equal fas fa-star per una stella piena.

### Loading States e Feedback

Ogni volta che fai una chiamata API, dovrai gestire tre stati: caricamento, successo ed errore. Creerai uno stato loading booleano che parte come false. Quando inizi la chiamata lo imposti a true. Quando la chiamata finisce, lo rimetti a false. Mentre loading è true, mostrerai un indicatore visivo. Potrebbe essere uno spinner animato, o skeleton screens che sono placeholder con l'aspetto degli elementi finali ma in grigio con un effetto shimmer. Gli skeleton sono ottimi perché danno all'utente un'idea di cosa sta per apparire senza creare ansia. Se la chiamata ha successo, salverai i dati nello stato e li mostrerai. Se fallisce, salverai l'errore in uno stato e mostrerai un messaggio chiaro all'utente, magari con un banner rosso in alto o un alert di Bootstrap.

## Sicurezza e Validazione

La sicurezza deve essere una priorità in ogni fase dello sviluppo. Anche se stai costruendo un progetto per imparare, è importante implementare le pratiche corrette fin dall'inizio così diventano abituali.

### Password Hashing

Mai e poi mai salvare password in chiaro nel database. Userai la libreria bcrypt che installi con npm. Quando un utente si registra, prima di salvare la password la passerai attraverso bcrypt.hash che prende la password e un salt factor, tipo dodici, e restituisce un hash. Questo hash è una stringa lunga e apparentemente casuale che non può essere decifrata per ottenere la password originale. Salverai questo hash nel database. Quando l'utente fa login, userai bcrypt.compare per confrontare la password inserita con l'hash salvato. Questa funzione applica lo stesso processo di hashing e vede se il risultato corrisponde, senza mai decriptare l'hash originale.

### SQL Injection

Questo è un attacco dove un malintenzionato cerca di inserire codice SQL dannoso nei tuoi input per manipolare il database. La difesa è semplice: non concatenare mai direttamente l'input dell'utente nelle query SQL. Usa sempre prepared statements o parameterized queries. In pratica, invece di scrivere SELECT asterisco FROM users WHERE email uguale apice più la variabile email più apice, scriverai SELECT asterisco FROM users WHERE email uguale punto interrogativo, e poi passerai l'email come parametro separato. Il database si occuperà automaticamente di escapare i caratteri speciali e prevenire l'injection.

### XSS Prevention

Cross-Site Scripting è quando un attaccante riesce a far eseguire JavaScript dannoso nel browser di altri utenti. React ti protegge automaticamente da questo perché quando renderizzi una stringa, la escapa di default. Ma devi fare attenzione se usi dangerouslySetInnerHTML che ti permette di renderizzare HTML grezzo. Usalo solo quando assolutamente necessario e sempre dopo aver pulito l'HTML con una libreria come DOMPurify che rimuove qualsiasi codice potenzialmente dannoso.

### Validazione Doppia

Anche se validi nel frontend, devi sempre validare di nuovo nel backend perché un utente esperto può facilmente bypassare la validazione JavaScript aprendo gli strumenti sviluppatore del browser o facendo richieste dirette con strumenti come Postman. La validazione backend è la tua ultima linea di difesa e garantisce che solo dati puliti e corretti entrino nel tuo database.

### CORS

Quando il tuo frontend React che gira su localhost tremila prova a chiamare il backend che gira su localhost cinquemila, il browser bloccherà la richiesta per ragioni di sicurezza chiamate CORS. Dovrai configurare il backend Express per permettere richieste dal tuo frontend usando la libreria cors. La installerai con npm e la userai come middleware che aggiunge gli headers appropriati alle risposte.

## Testing e Debug

Durante lo sviluppo userai diversi strumenti per testare e debuggare la tua applicazione.

MySQL Workbench ti permette di visualizzare il tuo database, vedere le tabelle e i dati, ed eseguire query manualmente per verificare che tutto sia salvato correttamente. Puoi anche usarlo per creare inizialmente le tabelle eseguendo gli script SQL di creazione.

Postman è fondamentale per testare la tua API backend prima ancora di collegare il frontend. Creerai richieste per ogni endpoint, specificando il metodo HTTP, l'URL, gli headers e il body. Potrai vedere esattamente cosa restituisce il server e verificare che tutto funzioni come previsto. Postman ti permette anche di salvare le richieste in collezioni così non devi ricrearle ogni volta.

Gli strumenti sviluppatore del browser sono essenziali per il frontend. La console JavaScript ti mostrerà eventuali errori nel codice. La tab Network ti farà vedere tutte le richieste HTTP che la pagina fa, utile per verificare che le chiamate API stiano funzionando. La tab Application ti permette di vedere cosa c'è nel local storage dove salvi il token JWT.

## Deployment e Conclusione

Quando avrai finito lo sviluppo e tutto funziona in locale, vorrai mettere la tua applicazione online così puoi mostrarla nel tuo portfolio. Ci sono vari servizi gratuiti che puoi usare. Per il frontend React puoi usare Netlify o Vercel che sono ottimizzati per applicazioni React e offrono deployment automatico collegandosi al tuo repository GitHub. Per il backend Node.js puoi usare Railway, Render o Heroku. Per il database MySQL puoi usare servizi cloud come PlanetScale o il database fornito dal servizio dove hosli il backend.

Il processo di deployment richiederà qualche configurazione in più come variabili d'ambiente per le informazioni sensibili tipo la chiave segreta JWT e le credenziali del database, ma ci sono molte guide disponibili per ogni servizio.

Questo progetto CineCircle ti darà un'esperienza completa di sviluppo full-stack. Costruirai un database relazionale complesso con molte tabelle e relazioni, creerai un'API REST completa con autenticazione e validazione, e svilupperai un frontend React dinamico e responsive. Alla fine avrai un progetto portfolio di cui essere orgoglioso che dimostra tutte le competenze tecniche che hai acquisito.

La chiave per completare questo progetto in una settimana è organizzare bene il lavoro. Ti consiglio di iniziare dal database e dal backend, perché senza dati e API il frontend non può fare nulla. Crea prima le tabelle, poi implementa gli endpoint uno alla volta testandoli con Postman. Quando il backend funziona, passa al frontend costruendo prima la struttura di base con React Router e i componenti principali, poi aggiungendo gradualmente le funzionalità. Non cercare di fare tutto perfetto al primo colpo, fai funzionare le cose e poi rifinisci.
