## Architettura dell'API Backend

Il tuo backend sarà costruito con Node.js usando il framework Express. L'API seguirà i principi REST, quindi ogni risorsa avrà URL chiari e userà i metodi HTTP in modo semantico. Organizzerai il codice in modo modulare per mantenere tutto ordinato e facile da modificare.

### Struttura delle Cartelle

Creerai diverse cartelle nel tuo progetto backend. La cartella routes conterrà tutti i file che definiscono gli endpoint dell'API, organizzati per risorsa. Avrai file come authRoutes.js per autenticazione, contentsRoutes.js per i contenuti, reviewsRoutes.js per le recensioni e così via. La cartella controllers conterrà la logica di business, quindi le funzioni che vengono eseguite quando un endpoint viene chiamato. La cartella models definirà come interagire con il database, probabilmente userai un query builder o scriverai le query SQL direttamente. La cartella middleware conterrà funzioni riutilizzabili come quella per verificare l'autenticazione o per validare i dati in ingresso. La cartella utils conterrà funzioni di utilità come quella per hashare le password o generare token.

### Autenticazione con JWT

Per gestire l'autenticazione userai JSON Web Tokens. Quando un utente fa login inviando email e password, il server controlla che le credenziali siano corrette. Per farlo, cerca l'utente nel database usando l'email. Se trova l'utente, usa la libreria bcrypt per confrontare la password inserita con l'hash salvato nel database. Se corrispondono, significa che la password è corretta. A questo punto il server genera un JWT usando la libreria jsonwebtoken. Il token contiene nel suo payload l'ID dell'utente e il suo username. Il token viene firmato con una chiave segreta che solo il server conosce, così nessuno può creare token falsi. Poi il token viene mandato al client che lo salverà e lo includerà in tutte le richieste successive.

Nel frontend, quando ricevi il token dopo il login, lo salvi nel local storage del browser usando localStorage.setItem. Poi, ogni volta che fai una richiesta a un endpoint protetto, recuperi il token con localStorage.getItem e lo metti nell'header della richiesta. Nel backend creerai un middleware di autenticazione che viene eseguito prima di certi endpoint. Questo middleware legge il token dall'header della richiesta, lo verifica usando la chiave segreta, e se è valido estrae l'ID dell'utente e lo aggiunge all'oggetto request. Così nei controller successivi puoi usare request.user.id per sapere chi sta facendo la richiesta.

### Endpoint Principali

Ora vediamo quali endpoint creerai nella tua API e cosa faranno. Ti darò una panoramica generale, poi quando implementerai potrai approfondire i dettagli.

Per l'autenticazione avrai POST slash auth slash register dove l'utente invia username, email e password nel body della richiesta. Il server controlla che l'email non esista già, hasha la password, crea un nuovo record nella tabella users e invia l'email di benvenuto. Poi c'è POST slash auth slash login dove l'utente invia email e password, il server verifica le credenziali e restituisce il JWT. C'è anche POST slash auth slash logout che nel caso dei JWT serve principalmente a far sì che il client elimini il token, ma potresti implementare una blacklist se vuoi invalidare token dal lato server.

Per i contenuti, l'endpoint principale è GET slash contents che restituisce una lista di film e serie TV. Questo endpoint accetta vari query parameters nell'URL. Il parametro search contiene la keyword da cercare nei titoli e nelle descrizioni. Il parametro genre contiene l'ID del genere per filtrare solo contenuti di quel genere. Il parametro year contiene l'anno o un range di anni. Il parametro sort indica come ordinare i risultati, può essere "title" per ordine alfabetico, "year" per anno di uscita, "rating" per valutazione media. I parametri page e limit gestiscono la paginazione, per esempio page uguale due e limit uguale venti significa che vuoi la seconda pagina di risultati con venti contenuti per pagina. Il server costruisce una query SQL che include tutti questi filtri e ordinamenti, la esegue sul database, e restituisce un oggetto JSON con i risultati e informazioni sulla paginazione.

Poi c'è GET slash contents slash slug dove slug è lo slug del contenuto che vuoi vedere. Questo endpoint restituisce tutti i dettagli di quel singolo contenuto. Il server fa una query che oltre a prendere i dati base del contenuto, fa un join con la tabella dei generi per includere tutti i generi associati, calcola la media delle recensioni, e magari include anche alcuni contenuti simili. Se l'utente è autenticato, il server controlla anche se quel contenuto è già nella sua collezione e in che stato.

Per la collezione personale, tutti gli endpoint richiedono autenticazione. GET slash my-collection restituisce tutti i contenuti nella collezione dell'utente loggato. Può accettare un parametro status per filtrare solo i contenuti in un certo stato. POST slash my-collection richiede un body con content_id e status, e aggiunge quel contenuto alla collezione dell'utente con lo stato specificato. PUT slash my-collection slash content-id permette di cambiare lo stato di un contenuto già nella collezione. DELETE slash my-collection slash content-id rimuove un contenuto dalla collezione.

Per le recensioni, GET slash reviews slash content-slug restituisce tutte le recensioni per quel contenuto, ordinate dalla più recente. POST slash reviews crea una nuova recensione dove il body contiene content_id, rating e text. Il server verifica che l'utente non abbia già recensito quel contenuto, salva la recensione nel database, e aggiorna il campo average_rating del contenuto ricalcolando la media. PUT slash reviews slash id modifica una recensione esistente, ma prima controlla che l'utente che fa la richiesta sia il proprietario di quella recensione. DELETE slash reviews slash id elimina una recensione con lo stesso controllo di proprietà.

Per le liste personalizzate, GET slash lists restituisce tutte le liste pubbliche o le liste dell'utente loggato se autenticato. GET slash lists slash id restituisce i dettagli di una lista specifica con tutti i contenuti che contiene. POST slash lists crea una nuova lista dove il body contiene name, description e is_public. PUT slash lists slash id modifica una lista esistente. DELETE slash lists slash id elimina una lista. POST slash lists slash id slash items aggiunge un contenuto a una lista, il body contiene content_id. DELETE slash lists slash id slash items slash content-id rimuove un contenuto da una lista.

Per il sistema di follow, POST slash follow slash user-id crea una relazione di follow tra l'utente loggato e l'utente specificato. DELETE slash follow slash user-id rimuove la relazione di follow. GET slash following restituisce tutti gli utenti che stai seguendo. GET slash followers restituisce tutti gli utenti che ti seguono. GET slash feed restituisce le attività recenti degli utenti che segui, interrogando la tabella activity_feed.

Per le statistiche, GET slash stats slash user-id restituisce statistiche personali dell'utente come numero totale di contenuti visti, distribuzione per generi, e altre informazioni calcolate dai suoi dati. GET slash stats slash global restituisce statistiche della piattaforma come i contenuti più popolari e i generi più seguiti.

### Validazione dei Dati

Ogni endpoint che riceve dati dall'utente deve validarli prima di usarli. Puoi creare funzioni di validazione personalizzate o usare una libreria. Per esempio, quando un utente si registra, devi controllare che lo username sia lungo almeno tre caratteri e non contenga caratteri speciali strani, che l'email sia in formato valido con la chiocciola e un dominio, e che la password sia lunga almeno otto caratteri. Se qualcosa non va, restituisci subito un errore quattrocento con un messaggio chiaro che spiega il problema, per esempio "La password deve essere lunga almeno otto caratteri".

### Gestione degli Errori

Creerai un sistema centralizzato per gestire gli errori. Alla fine della catena di middleware di Express, metterai un error handler che cattura tutti gli errori che non sono stati gestiti prima. Questo middleware riceve l'errore, determina che tipo di errore è, e restituisce una risposta JSON appropriata. Per esempio, se è un errore di validazione restituisce quattrocento con il messaggio di validazione. Se è un errore di autenticazione restituisce quattrocentouno. Se è una risorsa non trovata restituisce quattrocentoquattro. Per errori inaspettati che non hai previsto, restituisce cinquecento con un messaggio generico senza esporre dettagli interni che potrebbero essere informazioni sensibili.
